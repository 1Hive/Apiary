#!/usr/bin/env node
const fs = require('fs')
const got = require('got')
const _ = require('lodash')
const { createObjectCsvWriter } = require('csv-writer')

const QUERY = `query(
  $after: Cursor
) {
  organisations(
    take: 100
    after: $after
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      ens
      address
      activity
      aum
      ant
      proxies {
        appId
        app {
          name
        }
      }
    }
  }
}`

async function fetchPage (
  after = null
) {
  const {
    body: { data }
  } = await got.post('https://daolist.1hive.org', {
    json: {
      query: QUERY,
      variables: {
        after
      }
    },
    responseType: 'json'
  })

  return data
}

async function fetchData (quadratic) {
  let organisations = []
  let apps = []
  const totals = {
    activity: 1,
    aum: 1,
    ant: 1
  }

  // Fetch all the data
  let lastCursor
  let hasNextPage = true
  while (hasNextPage) {
    // Fetch the current page
    const data = await fetchPage(lastCursor)
    lastCursor = data.organisations.pageInfo.endCursor
    hasNextPage = data.organisations.pageInfo.hasNextPage

    // Filter out non-indexed apps
    const filtered = _.chain(data.organisations.nodes)
      .map((org) => ({
        ...org,
        proxies: org.proxies.filter((proxy) => proxy.app)
      }))
      .value()

    // Transform organisations in current page
    let transformed = _.chain(filtered)
      .map(_.partialRight(_.pick, [
        'address',
        'ens',
        'activity',
        'aum',
        'ant',
        'proxies'
      ]))
      .map((org) => ({
        ...org,
        proxies: org.proxies.length
      }))

    if (quadratic) {
      transformed = transformed.map(
        (org) => ({
          ...org,
          activitySqrt: Math.sqrt(org.activity),
          aumSqrt: Math.sqrt(org.aum),
          antSqrt: Math.sqrt(org.ant)
        })
      )
    }

    // Extract the data
    organisations = organisations.concat(
      transformed.value()
    )
    apps = apps.concat(
      _.chain(filtered)
        .flatMap((org) => org.proxies.map(
          (proxy) => ({
            organisation: org.address,
            id: proxy.appId,
            name: proxy.app.name
          })
        ))
        .value()
    )
  }

  // Calculate KPI totals
  if (quadratic) {
    totals.activity = _.sumBy(organisations, 'activitySqrt')
    totals.aum = _.sumBy(organisations, 'aumSqrt')
    totals.ant = _.sumBy(organisations, 'antSqrt')
  } else {
    totals.activity = _.sumBy(organisations, 'activity')
    totals.aum = _.sumBy(organisations, 'aum')
    totals.ant = _.sumBy(organisations, 'ant')
  }

  return {
    organisations: _.keyBy(organisations, 'address'),
    apps,
    totals
  }
}

function scoring (weights, quadratic) {
  const [
    activityWeight,
    aumWeight,
    antWeight
  ] = weights
  return function (data) {
    const organisationScores = _.chain(data.organisations)
      .mapValues((org) => {
        // Calculate normalized KPIs
        const normalizedActivity = (quadratic
          ? org.activitySqrt
          : org.activity) / data.totals.activity
        const normalizedAum = (quadratic
          ? org.aumSqrt
          : org.aum) / data.totals.aum
        const normalizedAnt = (quadratic
          ? org.antSqrt
          : org.ant) / data.totals.ant

        // Calculate score
        const score = normalizedActivity * activityWeight + normalizedAum * aumWeight + normalizedAnt * antWeight
        return {
          ...org,
          score
        }
      })
      .value()
    const appScores = _.chain(data.apps)
      .groupBy('id')
      .mapValues((instances) => {
        const score = _.chain(instances)
          .map((instance) => {
            const organisation = data.organisations[instance.organisation]

            const score = organisationScores[instance.organisation].score / organisation.proxies
            return score
          })
          .sum()
          .value()

        return {
          name: instances[0].name,
          id: instances[0].id,
          score
        }
      })
      .flatMap()
      .value()

    return {
      organisationScores: _.chain(organisationScores)
        .flatMap()
        .sortBy('score')
        .reverse()
        .value(),
      appScores: _.chain(appScores)
        .sortBy('score')
        .reverse()
        .value()
    }
  }
}

function saveScores ({
  organisationScores,
  appScores
}) {
  const orgScoreFile = createObjectCsvWriter({
    path: 'organisation_scores.csv',
    header: [{
      id: 'address',
      title: 'ADDRESS'
    }, {
      id: 'ens',
      title: 'ENS_NAME'
    }, {
      id: 'activity',
      title: 'ACTIVITY'
    }, {
      id: 'aum',
      title: 'AUM'
    }, {
      id: 'ant',
      title: 'ANT'
    }, {
      id: 'score',
      title: 'SCORE'
    }]
  })
  const appScoreFile = createObjectCsvWriter({
    path: 'app_scores.csv',
    header: [{
      id: 'id',
      title: 'APP_ID'
    }, {
      id: 'name',
      title: 'APP_NAME'
    }, {
      id: 'score',
      title: 'SCORE'
    }]
  })

  return Promise.all([
    orgScoreFile.writeRecords(organisationScores),
    appScoreFile.writeRecords(appScores)
  ])
}

// Parse command line parameters
const parameters = process.argv.slice(2)
if (parameters.length < 3) {
  console.error(`Usage: ./calcscore <activity weight> <aum weight> <ant weight> [--quad]`)
  process.exit(1)
}

// Parse --quad flag
const quadratic = _.indexOf(parameters, '--quad') > 0
if (quadratic) {
  parameters.splice(
    _.indexOf(parameters, '--quad'),
    1
  )
}

// Validate that weights add up to 1
const weights = _.map(parameters.slice(0, 3), Number)
const sumOfWeights = _.sum(weights)
if (sumOfWeights !== 1) {
  console.error(`The sum of the weights should be 1, is ${sumOfWeights}`)
  process.exit(1)
}

// Run script
console.log(`Calculating app scores (${quadratic ? 'quadratic' : 'linear'}, weights = [${weights.join(', ')}])`)
console.log('Fetching data...')
fetchData(quadratic)
  .then((data) => {
    console.log('Data fetched.')
    if (quadratic) {
      console.log('Note these are the sum of square roots of each KPI.')
    }

    console.log(`- ${_.size(data.organisations)} organisations`)
    console.log(`- ${_.size(data.apps)} app instances`)
    console.log(`- ${data.totals.activity} total activity`)
    console.log(`- ${data.totals.aum} total AUM`)
    console.log(`- ${data.totals.ant} total ANT`)

    return data
  })
  .then(
    scoring(weights, quadratic)
  )
  .then((scores) => {
    const orgScoreSum = _.sumBy(scores.organisationScores, 'score')
    const appScoreSum = _.sumBy(scores.appScores, 'score')
    console.log('Calculated scores.')
    console.log(`Sanity check; organisation score sum = ${orgScoreSum}, app score sum = ${appScoreSum}`)

    return scores
  })
  .then(saveScores)
  .then(() => {
    console.log('Saved scores to disk.')
  })
  .catch((err) => {
    console.error('An error occurred')
    console.error(err)
  })
